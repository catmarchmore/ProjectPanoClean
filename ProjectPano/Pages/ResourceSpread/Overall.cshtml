@page
@using System.Text.Json
@using ProjectPano
@model ProjectPano.Pages.ResourceSpread.OverallModel
@{
    ViewData["FullWidth"] = false;
    ViewData["Title"] = "Overall Stacked Area Chart";

    var spreadDataJson = JsonSerializer.Serialize(Model.SpreadWeeks, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });
}

<!-- ✅ CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
<link rel="stylesheet" href="~/css/site.css" asp-append-version="true" />
<link rel="stylesheet" href="~/ProjectPano.styles.css" asp-append-version="true" />

<!-- ✅ Scripts -->
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>

<h4 class="custom-h1">Overall Stacked Area Chart</h4>

<a href="/ResourceSpread/Home">Back</a>
<br />
<br/>

<label>
    <input type="radio" name="spreadMode" value="hrs" checked> Show Full Value of Opportunities
</label>
<label>
    <input type="radio" name="spreadMode" value="prob"> Show Probability Value of Opportunities
</label>
<br />
<br />

@* <canvas id="stackedAreaChart" height="400"></canvas> *@

<div id="canvasWrapperMAIN">
    <canvas id="stackedAreaChart"></canvas>
</div>

<script>
    const spreadData = @Html.Raw(spreadDataJson);
    const jsonSizeKB = new Blob([JSON.stringify(spreadData)]).size / 1024;
    console.log(`Spread JSON size: ${jsonSizeKB.toFixed(1)} KB`);

    // Toggle mode: 'hrs' or 'prob'
    let spreadMode = 'hrs';
    document.querySelectorAll('input[name="spreadMode"]').forEach(radio => {
        radio.addEventListener('change', e => {
            spreadMode = e.target.value;
            renderChart();
        });
    });

    // Global constants for colors & special clients
    const specialClients = ["RFP Submitted", "RFP Received", "Qualified"];
    const excelColorful40 = [
        "#5B9BD5","#ED7D31","#A5A5A5","#FFC000","#4472C4","#70AD47",
        "#255E91","#9E480E","#636363","#997300","#264478"
    ];
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }
    const shuffledColors = shuffleArray([...excelColorful40]);

    // Highlight plugin for actuals shading
    const highlightActualsPlugin = {
        id: 'highlightActuals',
        beforeDatasetsDraw(chart, args, options) {
            const {ctx, chartArea: {left, right, top, bottom}, scales: {x}} = chart;
            const numWeeks = options.numWeeks || 4;
            const label = options.label || 'Actuals';
            const color = options.color || 'rgba(200,200,200,0.3)';
            const xStart = x.getPixelForValue(0);
            const xEnd = x.getPixelForValue(numWeeks - 1);

            ctx.save();
            ctx.fillStyle = color;
            ctx.fillRect(xStart, top, xEnd - xStart, bottom - top);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(label, (xStart + xEnd)/2, top + 5);
            ctx.restore();
        }
    };

    // Utility to calculate contrast for labels
    function getContrastColor(hexOrRgb, options={darkColor:'#000', lightColor:'#fff'}) {
        let r, g, b;
        if (hexOrRgb.startsWith('#')) {
            const hex = hexOrRgb.replace('#','');
            r = parseInt(hex.substring(0,2),16);
            g = parseInt(hex.substring(2,4),16);
            b = parseInt(hex.substring(4,6),16);
        } else if (hexOrRgb.startsWith('rgb')) {
            const nums = hexOrRgb.match(/\d+/g).map(Number);
            [r,g,b] = nums;
        } else return options.darkColor;

        const brightness = (r*299 + g*587 + b*114)/1000;
        return brightness > 128 ? options.darkColor : options.lightColor;
    }

    let chartInstance; // hold Chart.js instance

    function renderChart() {
        // 1️⃣ Build grouped data based on spreadMode
        const grouped = {};
        const lines = {};
        spreadData.forEach(item => {
            if (!item.weekEnding) return;
            const week = item.weekEnding.split('T')[0];
            if (!grouped[week]) grouped[week] = {};
            if (!grouped[week][item.stackedAreaClient]) grouped[week][item.stackedAreaClient] = 0;

            const val = spreadMode === 'prob' ? (item.spreadHrsProb || 0) : item.spreadHrs;
            grouped[week][item.stackedAreaClient] += val;

            if (!lines[week]) {
                lines[week] = {
                    TotalWklyBillableOH: item.totalWklyBillableOH || 0,
                    TotalWklyBillableOHOT: item.totalWklyBillableOHOT || 0
                };
            }
        });

        const weekLabels = Object.keys(grouped).sort();
        const limitedWeekLabels = weekLabels.slice(0, 20);

        // 2️⃣ Determine clients & assign colors
        const allClients = new Set();
        weekLabels.forEach(week => Object.keys(grouped[week]).forEach(c => allClients.add(c)));

        const sortedClients = Array.from(allClients)
            .filter(c => !specialClients.includes(c))
            .sort((a,b)=> a.localeCompare(b))
            .concat(specialClients);

        const clientColors = {};
        sortedClients.forEach((client, index) => {
            if (client === "RFP Submitted") clientColors[client] = "rgba(128,128,128)";
            else if (client === "RFP Received") clientColors[client] = "rgba(255,0,255)";
            else if (client === "Qualified") clientColors[client] = "rgba(135,206,235)";
            else clientColors[client] = shuffledColors[index % shuffledColors.length];
        });

        // 3️⃣ Build datasets
        const datasets = [];

        // Regular clients first
        sortedClients.filter(c => !specialClients.includes(c)).forEach(client => {
            const values = limitedWeekLabels.map(week => grouped[week]?.[client] || 0);
            const max = Math.max(...values);
            const maxIndex = values.indexOf(max);

            datasets.push({
                label: client,
                data: values,
                backgroundColor: clientColors[client],
                borderColor: clientColors[client],
                fill: true,
                type: 'line',
                stack: 'clientStack',
                order: 0,
                tension: 0,
                borderWidth: 1,
                pointRadius: 0,
                datalabels: {
                    display: context => context.dataIndex === maxIndex && max > 140,
                    align: 'center',
                    anchor: 'center',
                    formatter: () => client,
                    font: { weight: 'bold' },
                    color: context => getContrastColor(context.dataset.backgroundColor, {darkColor:'#fff', lightColor:'#fff'}),
                    textStrokeColor: 'rgba(0,0,0,0.4)',
                    textStrokeWidth: 1
                }
            });
        });

        // Special clients on top
        specialClients.forEach(client => {
            const values = limitedWeekLabels.map(week => grouped[week]?.[client] || 0);
            const max = Math.max(...values);
            const maxIndex = values.indexOf(max);

            datasets.push({
                label: client,
                data: values,
                backgroundColor: clientColors[client],
                borderColor: clientColors[client],
                fill: {target:'origin'},
                type: 'line',
                stack: 'clientStack',
                order: 1,
                tension: 0,
                borderWidth: 1,
                pointRadius: 0,
                datalabels: {
                    display: context => context.dataIndex === maxIndex && max > 120,
                    align: 'bottom',
                    anchor: 'end',
                    formatter: () => client,
                    font: { weight: 'bold' },
                    color: '#333'
                }
            });
        });

        // Capacity lines
        datasets.push(
            {
                label: 'TotalWklyBillableOH',
                data: limitedWeekLabels.map(week => lines[week]?.TotalWklyBillableOH || 0),
                borderColor: 'red',
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                type: 'line',
                order: 1000,
                pointRadius: 0,
                tension: 0
            },
            {
                label: 'TotalWklyBillableOHOT',
                data: limitedWeekLabels.map(week => lines[week]?.TotalWklyBillableOHOT || 0),
                borderColor: 'red',
                borderDash: [5,5],
                borderWidth: 2,
                fill: false,
                yAxisID: 'y2',
                type: 'line',
                order: 1000,
                pointRadius: 0,
                tension: 0
            }
        );

        // 4️⃣ Render Chart
        const ctx = document.getElementById('stackedAreaChart').getContext('2d');
        if(chartInstance) chartInstance.destroy();
        chartInstance = new Chart(ctx, {
            type: 'line',
            data: { labels: limitedWeekLabels, datasets: datasets },
            options: {
                responsive: true,
                interaction: { mode:'nearest', intersect:false },
                scales: {
                    x: {
                        stacked: true,
                        title: { display:true, text:'Week Ending' },
                        ticks: {
                            callback: function(value) {
                                const raw = this.getLabelForValue(value);
                                const date = new Date(raw);
                                return isNaN(date) ? raw : `${date.getMonth()+1}/${date.getDate()+1}`;
                            }
                        }
                    },
                    y: { stacked:true, min:0, max:2500, title:{display:true,text:'Hours'} },
                    y2: { position:'right', stacked:false, min:0, max:2500, display:true, grid:{drawOnChartArea:false}, title:{display:true,text:'Capacity'} }
                },
                plugins: {
                    highlightActuals: { numWeeks: 4, label:'Actuals', color:'rgba(128,128,128,0.25)' },
                    legend: { position:'right', labels:{ font:{size:10}, boxWidth:12, padding:8 }, maxHeight:300, layout:{padding:{right:20}} },
                    title: { display:false },
                    datalabels:{ display:false }
                }
            },
            plugins: [ChartDataLabels, highlightActualsPlugin]
        });
    }

    // Initial render
    renderChart();


    // const spreadData = @Html.Raw(spreadDataJson);
    // const jsonSizeKB = new Blob([JSON.stringify(spreadData)]).size / 1024;
    // console.log(`Spread JSON size: ${jsonSizeKB.toFixed(1)} KB`);

    // //toggle between full or prob value
    // let spreadMode = 'hrs'; // default
    // document.querySelectorAll('input[name="spreadMode"]').forEach(radio => {
    //     radio.addEventListener('change', e => {
    //         spreadMode = e.target.value;
    //         renderChart();  // redraw chart with new mode
    //     });
    // });



    //     // Prep structures
    //     const grouped = {};
    //     const lines = {};

    //     spreadData.forEach(item => {
    //         if (!item.weekEnding) return;

    //         const week = item.weekEnding.split('T')[0];

    //         if (!grouped[week]) grouped[week] = {};
    //         if (!grouped[week][item.stackedAreaClient]) grouped[week][item.stackedAreaClient] = 0;

    //         // Combine Actual + ETC
    //         //grouped[week][item.stackedAreaClient] += item.spreadHrs;
    //         const val = spreadMode === 'prob' ? (item.spreadHrsProb || 0) : item.spreadHrs;
    //         grouped[week][item.stackedAreaClient] += val;


    //         if (!lines[week]) {
    //             lines[week] = {
    //                 TotalWklyBillableOH: item.totalWklyBillableOH || 0,
    //                 TotalWklyBillableOHOT: item.totalWklyBillableOHOT || 0
    //             };
    //         }
    //     });

    //     //console.log(lines);

    //     const weekLabels = Object.keys(grouped).sort();
    //     const limitedWeekLabels = weekLabels.slice(0, 20); // ⬅️ First 20 weeks only

    //     // Client sorting
    //     //const clientOrder = ["Qualified", "RFP Received", "RFP Submitted"];
    //     const specialClients = ["RFP Submitted", "RFP Received", "Qualified"];
    //     const allClients = new Set();
    //     weekLabels.forEach(week => {
    //         Object.keys(grouped[week]).forEach(c => allClients.add(c));
    //     });

    //     // Sort: normal clients A–Z, then the 3 special ones in custom order
    //     const sortedClients = Array.from(allClients)
    //         .filter(c => !specialClients.includes(c)) // alpha clients
    //         .sort((a, b) => a.localeCompare(b))
    //         .concat(specialClients); // add special ones last

    //     const excelColorful40 = [
    //         "#5B9BD5","#ED7D31","#A5A5A5","#FFC000","#4472C4","#70AD47",
    //         "#255E91","#9E480E","#636363","#997300","#264478"
    //         // just 10–12 solid, distinct colors
    //     ];

    //     function shuffleArray(array) {
    //         for (let i = array.length - 1; i > 0; i--) {
    //             const j = Math.floor(Math.random() * (i + 1));
    //             [array[i], array[j]] = [array[j], array[i]];
    //         }
    //         return array;
    //     }

    //     // Shuffle colors once
    //     const shuffledColors = shuffleArray([...excelColorful40]);

    //     const clientColors = {};

    //     // Color map
    //     //const clientColors = {};
    //     sortedClients.forEach((client, index) => {
    //         if (client === "RFP Submitted") {
    //             clientColors[client] = "rgba(128, 128, 128)"; //gray
    //             //clientColors[client] = "rgba(255, 0, 0)"; //red
    //         } else if (client === "RFP Received") {
    //             clientColors[client] = "rgba(255, 0, 255)";   // fuchsia
    //         } else if (client === "Qualified") {
    //             clientColors[client] = "rgba(135, 206, 235)"; // skyblue
    //         } else {
    //             clientColors[client] = shuffledColors[index % shuffledColors.length];
    //         }
    //     });

    //     //shade the actuals
    //     // Plugin to shade first N columns
    //     const highlightActualsPlugin = {
    //         id: 'highlightActuals',
    //         beforeDatasetsDraw(chart, args, options) {
    //             const {ctx, chartArea: {left, right, top, bottom}, scales: {x, y}} = chart;
    //             const numWeeks = options.numWeeks || 4; // first 4 weeks
    //             const label = options.label || 'Actuals';
    //             const color = options.color || 'rgba(200,200,200,0.3)'; // translucent gray

    //             // Width of one column
    //             const xStart = x.getPixelForValue(0);
    //             const xEnd = x.getPixelForValue(numWeeks - 1);

    //             ctx.save();
    //             ctx.fillStyle = color;
    //             ctx.fillRect(xStart, top, xEnd - xStart, bottom - top);

    //             // Optional label
    //             ctx.fillStyle = '#000';
    //             ctx.font = 'bold 12px sans-serif';
    //             ctx.textAlign = 'center';
    //             ctx.textBaseline = 'top';
    //             ctx.fillText(label, (xStart + xEnd)/2, top + 5);

    //             ctx.restore();
    //         }
    //     };

    //     //const datasets = [];
    //     const datasets=buildDatasets(grouped,limitedWeekLabels);

    //     function getContrastColor(hexOrRgb, options={darkColor:'#000', lightColor:'#fff'}) {
    //         let r, g, b;
    //         if (hexOrRgb.startsWith('#')) {
    //             const hex = hexOrRgb.replace('#','');
    //             r = parseInt(hex.substring(0,2),16);
    //             g = parseInt(hex.substring(2,4),16);
    //             b = parseInt(hex.substring(4,6),16);
    //         } else if (hexOrRgb.startsWith('rgb')) {
    //             const nums = hexOrRgb.match(/\d+/g).map(Number);
    //             [r,g,b] = nums;
    //         } else return options.darkColor;

    //         const brightness = (r*299 + g*587 + b*114)/1000;
    //         return brightness > 128 ? options.darkColor : options.lightColor;
    //     }

    //     // 1️⃣ Regular clients first (rendered underneath)
    //     sortedClients
    //         .filter(c => !specialClients.includes(c))
    //         .forEach((client, index) => {
    //             const values = limitedWeekLabels.map(week => grouped[week]?.[client] || 0);
    //             const max = Math.max(...values);
    //             const maxIndex = values.indexOf(max);

    //             datasets.push({
    //                 label: client,
    //                 data: values,
    //                 backgroundColor: clientColors[client],
    //                 borderColor: clientColors[client],
    //                 fill: true,
    //                 type: 'line',
    //                 stack: 'clientStack',
    //                 // tension: 0.4,
    //                 order:0,
    //                 tension:0,
    //                 borderWidth: 1,
    //                 pointRadius: 0,
    //                 datalabels: {
    //                     display: context => context.dataIndex === maxIndex && max > 140,
    //                     align: 'center',
    //                     anchor: 'center',
    //                     formatter: () => client,
    //                     font: { weight: 'bold' },
    //                     color: context => {
    //                         const bg = context.dataset.backgroundColor;
    //                         return getContrastColor(bg, {darkColor:'#fff', lightColor:'#fff'});  /* gray #333 to #666 */
    //                     },
    //                     textStrokeColor: 'rgba(0,0,0,0.4)',
    //                     textStrokeWidth: 1
    //                 }
    //             });
    //         });

    //     // 2️⃣ Special clients last (rendered on top)
    //     specialClients.forEach((client) => {
    //         const values = limitedWeekLabels.map(week => grouped[week]?.[client] || 0);
    //         const max = Math.max(...values);
    //         const maxIndex = values.indexOf(max);

    //         datasets.push({
    //             label: client,
    //             data: values,
    //             backgroundColor: clientColors[client],
    //             borderColor: clientColors[client],
    //             //fill: true,
    //             fill:{target:'origin'},
    //             type: 'line',
    //             stack: 'clientStack',
    //             // tension: 0.4,
    //             tension:0,
    //             borderWidth: 1,
    //             pointRadius: 0,
    //             order:1,
    //             //z:1,
    //             datalabels: {
    //                 display: context => context.dataIndex === maxIndex && max > 120,
    //                 align: 'bottom',  /*  ('top', 'center', 'bottom', 'left', 'right') */
    //                 anchor: 'end',  /* ('start', 'center', 'end') */
    //                 formatter: () => client,
    //                 font: { weight: 'bold' },
    //                 color: '#333'
    //             }
    //         });
    //     });


    //     // Capacity lines
    //     datasets.push(
    //     {
    //         label: 'TotalWklyBillableOH',
    //         data: limitedWeekLabels.map(week => lines[week]?.TotalWklyBillableOH || 0),
    //         borderColor: 'red',
    //         borderWidth: 2,
    //         fill: false,
    //         yAxisID: 'y2',
    //         type: 'line',
    //         order: 1000,            // highest order
    //         pointRadius: 0,
    //         tension: 0
    //     },
    //     {
    //         label: 'TotalWklyBillableOHOT',
    //         data: limitedWeekLabels.map(week => lines[week]?.TotalWklyBillableOHOT || 0),
    //         borderColor: 'red',
    //         borderDash: [5, 5],
    //         borderWidth: 2,
    //         fill: false,
    //         yAxisID: 'y2',
    //         type: 'line',
    //         order: 1000,
    //         pointRadius: 0,
    //         tension: 0
    //     }
    //     );

    //     // Chart rendering
    //     Chart.register(ChartDataLabels);
    //     Chart.register(highlightActualsPlugin);
    //     new Chart(document.getElementById('stackedAreaChart').getContext('2d'), {
    //         type: 'line',
    //         data: {
    //             labels: limitedWeekLabels,
    //             datasets: datasets
    //         },
    //         options: {
    //             responsive: true,
    //             interaction: {
    //                 mode: 'nearest',
    //                 intersect: false
    //             },
    //             scales: {
    //                 x: {
    //                     stacked: true,
    //                     title: { display: true, text: 'Week Ending' },
    //                     ticks: {
    //                         callback: function (value) {
    //                             const raw = this.getLabelForValue(value); //value; // this.getLabelForValue(value);
    //                             const date = new Date(raw);
    //                             return isNaN(date) ? raw : `${date.getMonth() + 1}/${date.getDate() + 1}`;
    //                             //return `${date.getMonth() + 1}/${date.getDate()+1}`;
    //                         }
    //                     }
    //                 },
    //                 y: {
    //                     stacked: true, // ✅ not stacked
    //                     min:0,
    //                     max:2500,
    //                     title: { display: true, text: 'Hours' }
    //                 },
    //                 y2: {
    //                     position:'right',
    //                     min:0,
    //                     max:2500,
    //                     display:true,
    //                     stacked:false,
    //                     grid:{
    //                         drawOnChartArea:false
    //                     },
    //                     title:{
    //                         display:true,
    //                         text:'Capacity'
    //                     }
    //                 }
    //             },
    //             plugins: {
    //                 highlightActuals: {
    //                     numWeeks: 4,
    //                     label: 'Actuals',
    //                     color: 'rgba(128, 128, 128, 0.25)'
    //                 },
    //                 legend: { 
    //                     position: 'right' ,
    //                     labels:{
    //                         font:{
    //                             size:10
    //                         },
    //                         boxWidth:12,
    //                         padding:8
    //                     },
    //                     maxHeight:300,
    //                     layout:{
    //                         padding:{
    //                             right:20
    //                         }
    //                     }
    //                 },
    //                 title: {
    //                     display: false,
    //                     text: 'By Client'
    //                 },
    //                 datalabels:{
    //                     display:false
    //                 }
    //             }
    //         }
    // });
</script>
